{
  "history": [
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "gradient",
      "usesPingPong": false,
      "speed": 0.25,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) { switch(index) { case 0: return vec3(0, 0, 0); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"
      ],
      "data": {
        "downSample": 0.5,
        "depth": false,
        "uniforms": {},
        "isBackground": true
      },
      "id": "effect"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "sdf_shape",
      "usesPingPong": false,
      "texture": false,
      "speed": 0,
      "trackMouseMove": 0.1,
      "trackAxes": "xy",
      "mouseMomentum": 1,
      "trackMouse": 0.25,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; precision highp int;in vec2 vTextureCoord; uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }const float PI = 3.141592653; const float PI2 = 6.283185306; const int DISP_STEPS = 12; const vec3 viewDir = vec3(0,0, -4.25);ivec2 customTexSize; float customTexAspect;const mat3 ROT_Y_90 = mat3( 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 0.0 );const mat3 ROT_Z_90 = mat3( 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 );const mat3 ROT_X_90 = mat3( 1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0 );mat3 rotY(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c); }mat3 rotX(float ang) { float c = cos(ang), s = sin(ang); return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c); }mat3 rotZ(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0); }vec3 twistY(vec3 p, float amount) { float c = cos(amount * p.y); float s = sin(amount * p.y); mat2 m = mat2(c, -s, s, c); return vec3(m * p.xz, p.y); }vec3 twistX(vec3 p, float amount) { float c = cos(amount * p.x); float s = sin(amount * p.x); mat2 m = mat2(c, -s, s, c); return vec3(p.x, m * p.yz); }float sdfCylinder(vec3 p, float radius, float height) { vec2 d = abs(vec2(length(p.xz) - radius, p.y)) - vec2(radius, height * 0.5); return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)); }float sdStar5(vec2 p, float r, float rf) { const vec2 k1 = vec2(0.809016994375, -0.587785252292); const vec2 k2 = vec2(-k1.x,k1.y); p.x = abs(p.x); p -= 2.0*max(dot(k1,p),0.0)*k1; p -= 2.0*max(dot(k2,p),0.0)*k2; p.x = abs(p.x); p.y -= r; vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1); float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r ); return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y); }vec3 getRepeat(vec3 p) { float spacing = (0.0000 + 0.1000 * 0.38) * 8.; return p; }vec3 getThreeDRepeat(vec3 p) { float spacing = (0.0000 + 0.1000 * 0.38) * 8.; return p; }vec3 getAdjustedP(vec3 p) { float scale = max(0.6000, 0.000000001); float scaleFactor = 1.0/scale; vec3 adjustedP = p * scaleFactor;vec2 twist = vec2(0, 0);adjustedP.xy *= vec2(uResolution.x / uResolution.y, 1);adjustedP *= (1. + (0.1000 + 0.01));vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.2500); vec2 axis = vec2(-1. * vec3(0.5, 0.75, 0).y - 1. + mousePos.y/PI, vec3(0.5, 0.75, 0).x + mousePos.x/PI) * 2.;adjustedP = getRepeat(adjustedP);float baseTime = uTime * 0.02; float timeX = vec3(0, 1, 0).x * baseTime; float timeY = vec3(0, 1, 0).y * baseTime; float timeZ = vec3(0, 1, 0).z * baseTime;mat3 rotYMat = rotY(axis.y * PI); mat3 rotXMat = rotX(axis.x * PI); mat3 rotZMat = rotZ(vec3(0.5, 0.75, 0).z * 2.0 * PI);mat3 combinedRotation = rotZMat * rotYMat * rotXMat; mat3 combinedAnimation = rotZ(timeZ) * rotX(timeX) * rotY(timeY);adjustedP = combinedRotation * adjustedP; adjustedP = combinedAnimation * adjustedP; adjustedP = getThreeDRepeat(adjustedP); adjustedP = mix(adjustedP, twistY(adjustedP, -1.0 * twist.y), step(0.0, abs(twist.y))); adjustedP = mix(adjustedP, twistX(adjustedP, -1.0 * twist.x), step(0.0, abs(twist.x)));return adjustedP; }float getMergedSDF(vec3 p) { p = getAdjustedP(p); return sdfCylinder(p, 0.7, 0.05 + 0.25 * 0.1000); }vec3 calculateNormal(vec3 p, float eps) { vec2 e = vec2(1.0, -1.0) * eps * 0.5; return normalize( e.xyy * getMergedSDF(p + e.xyy) + e.yyx * getMergedSDF(p + e.yyx) + e.yxy * getMergedSDF(p + e.yxy) + e.xxx * getMergedSDF(p + e.xxx) ); }float scene(vec3 p) { return max(0.0000000001, getMergedSDF(p) - (0.1000 + 0.005)) * max(0.6000, 0.000000001); }const int STEPS = 128; const float MAX_DISTANCE = 100.0;vec4 rayMarch(vec3 ro, vec3 rd) { float pixelSize = 0.0025; float traveled = 0.; vec3 entryPoint = vec3(0.0); vec3 entryNormal = vec3(0.0); float partialAlpha = 0.0; float lastDistance = 0.0; float smoothing = mix(1., 4., 1.0000);for (int i = 0; i < STEPS; ++i) { vec3 currentPos = ro + rd * traveled; float distance = scene(currentPos); float progress = float(i)/float(STEPS); float step = distance * mix(1., 1.5, progress);if (distance > MAX_DISTANCE) break;if (distance < pixelSize) { partialAlpha = 1.; entryPoint = currentPos; entryNormal = calculateNormal(entryPoint, pixelSize * smoothing); break; }lastDistance = distance;traveled += max(step, pixelSize); if (traveled > MAX_DISTANCE) break; }if (partialAlpha == 0.0) { return texture(uTexture, vTextureCoord); }vec3 samplePosition = mix(rd, entryPoint, 0.0000);vec3 refractionColor = vec3(0.0); vec3 lightDir = vec3(((vec2(vec3(0.25, 0.25, -3).x, 1.-vec3(0.25, 0.25, -3).y) - 0.333) * 3.) - vec2(0.5, 0.5), vec3(0.25, 0.25, -3).z); vec3 normLightDir = normalize(lightDir);float lightAndShadow = dot(entryNormal, normLightDir); vec3 lightColor = mix(vec3(1), vec3(0.5019607843137255, 0.5019607843137255, 0.5019607843137255), 1. - 1.0000); vec3 fresnelEffect = vec3(0.0);vec3 specularEffect = vec3(0.0);vec3 halfwayDir = normalize(lightDir + rd); float specFactor = pow(max(dot(entryNormal, halfwayDir), 0.0), 64.0 * 1.0000 + 0.01); specularEffect = specFactor * 1.0000 * lightColor;vec3 combinedEffects = fresnelEffect + specularEffect; vec3 finalColor = mix(refractionColor, vec3(0.5019607843137255, 0.5019607843137255, 0.5019607843137255) * lightAndShadow, 1.0000); finalColor += combinedEffects;vec4 outputColor = vec4(finalColor, 1.);return outputColor; }out vec4 fragColor;void main() { vec4 col = vec4(0); vec4 bg = texture(uTexture, vTextureCoord);if(0.6000 <= 0.0001 || 1.0000 <= 0.0001) { col = vec4(0); if(1 == 1) { col = bg; } fragColor = col; return; }vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.1000); vec2 uv = vTextureCoord - pos; float fovFactor = tan(radians(20.) * 0.5); vec3 rd = vec3(uv * fovFactor, 0.5); col = rayMarch(viewDir, rd); float dither = (randFibo(vTextureCoord.xy) - 0.5) / 255.0; col += dither;col = mix(bg, col, 1.0000); fragColor = col;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect1"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "swirl",
      "usesPingPong": false,
      "speed": 0.5,
      "trackMouse": 0.1,
      "trackAxes": "xy",
      "mouseMomentum": 1,
      "texture": false,
      "animating": true,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor; void main() { vec2 uv = vTextureCoord; float angle = 1.0000 * 10.; vec2 originalUV = uv; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.1000);uv -= pos; vec2 R = vec2(uv.x * uResolution.x / uResolution.y, uv.y); float distanceToCenter = length(R); distanceToCenter += 0.0000*0.5; if (distanceToCenter <= 0.4000) { float rot = atan(R.y, R.x) + angle * smoothstep(0.4000, 0., distanceToCenter); uv = vec2(cos(rot + uTime / 20. + 0.0000 * 6.28), sin(rot + uTime / 20. + 0.0000 * 6.28)); uv = distanceToCenter * uv + pos; } float t = smoothstep(0., 0.4000, distanceToCenter); vec2 mixedUV = mix(uv, originalUV, t);vec4 color = texture(uTexture, mix(vTextureCoord, mixedUV, 1.0000)); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect2"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "voronoi",
      "usesPingPong": false,
      "speed": 0.2,
      "trackMouse": 0.1,
      "trackAxes": "xy",
      "mouseMomentum": 1,
      "texture": false,
      "animating": true,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } vec2 random2( vec2 p ) { return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453); }const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } out vec4 fragColor;vec2 voronoidNoise(vec2 st) { vec2 i_st = floor(st); vec2 f_st = fract(st);float m_dist = 15.; vec2 m_point; vec2 d;for (int j=-1; j<=1; j++ ) { for (int i=-1; i<=1; i++ ) { vec2 neighbor = vec2(float(i),float(j)); vec2 point = random2(i_st + neighbor);point = 0.5 + 0.5 * sin(5. + uTime * 0.2 + 6.2831*point); vec2 diff = neighbor + point - f_st; float dist = length(diff);if( dist < m_dist ) { m_dist = dist; m_point = point; d = diff; } } }return m_point; } vec2 voronoiFBM(vec2 st) { vec2 value = vec2(0.0); vec2 shift = vec2(100.0); float xp = sqrt(2.); mat2 r = rot(0.5); for (int i = 0; i < 8; i++) { value += voronoidNoise(st); st = st * xp + shift; st = r * st; } return value / float(8); } void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y;vec2 skew = mix(vec2(1), vec2(1, 0), 0.0000);vec2 st = (uv - vec2(0.5, 0.5)) * vec2(aspectRatio, 1.) * 50. * 0.0500; st = st * rot(0.0000 * 2. * PI) * skew; vec2 m_point = voronoiFBM(st);vec2 offset = (m_point * 0.2 * 0.2000 * 2.) - (0.2000 * 0.2);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.1000); vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); float dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000)));vec4 color = texture(uTexture, uv + offset * dist); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect3"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "wisps",
      "usesPingPong": false,
      "speed": 0.05,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": true,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }out vec4 fragColor; const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 hash(vec2 p) { p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3))); return -1.0 + 2.0 * fract(sin(p) * 43758.5453123); }float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }float voronoi_additive(vec2 st, float radius, vec2 mouse_pos, float scale) { vec2 i_st = floor(st); vec2 f_st = fract(st);float wander = 1.0000 * uTime * 0.2; float total_contribution = 0.0;for (int y = -2; y <= 2; y++) { for (int x = -2; x <= 2; x++) { vec2 neighbor = vec2(float(x), float(y)); vec2 cell_id = i_st + neighbor; vec2 point = hash(cell_id); point = 0.5 + 0.5 * sin(5. + wander + 6.2831 * point); vec2 starAbsPos = cell_id + point; vec2 dirToMouse = mouse_pos - starAbsPos; float distToMouse = length(dirToMouse); float attractStrength = 1.0000 * exp(-distToMouse * mix(2.0 + 0.5000 * 2., 0.5, 1.0000)) * 2.; starAbsPos += dirToMouse * attractStrength; vec2 diff = starAbsPos - st; float dist = length(diff);float contribution = radius / max(dist, radius * 0.1); float shimmer_phase = dot(point, vec2(1.0)) * 10. + hash(cell_id).x * 5.0 + uTime * 0.5; float shimmer = mix(1., (sin(shimmer_phase) + 1.), 1.0000); contribution *= shimmer; total_contribution += mix(contribution*contribution, contribution * 2., 0.0000); } }return total_contribution; }vec4 randomStyle() { vec2 uv = vTextureCoord;vec4 bg = texture(uTexture, uv);vec4 color = vec4(0.0); vec2 aspectRatio = vec2(uResolution.x / uResolution.y, 1.0);vec2 mPos = mix(vec2(0.0), (uMousePos - 0.5), 0.0000);uv -= vec2(0.5, 0.5); uv *= aspectRatio; uv = uv * rot(0.0000 * 2.0 * PI); uv *= 40.0 * 0.5000; uv *= mix(vec2(1.0), vec2(1.0, 0.0), 0.0000); uv /= aspectRatio;mPos = mPos * rot(0.0000 * 2.0 * PI);vec2 mouseGrid = uMousePos; mouseGrid -= vec2(0.5, 0.5); mouseGrid *= aspectRatio; mouseGrid = mouseGrid * rot(0.0000 * 2.0 * PI); mouseGrid *= 40.0 * 0.5000; mouseGrid *= mix(vec2(1.0), vec2(1.0, 0.0), 0.0000); mouseGrid /= aspectRatio;vec2 movementOffset = vec2(0.0, uTime * 1.0000 * -0.05); vec2 mouseGrid1 = mouseGrid - (mPos * 38.0 * 0.5000) + movementOffset; vec2 mouseGrid2 = mouseGrid - (mPos * 48.0 * 0.5000) + movementOffset;vec2 st1 = uv - (mPos * 38.0 * 0.5000); vec2 st2 = uv - (mPos * 48.0 * 0.5000);vec2 mouse1 = st1 + vec2(0.0, uTime * 1.0000 * -0.05); vec2 mouse2 = st2 + vec2(0.0, uTime * 1.0000 * -0.05);float radius1 = 0.5 * 1.0000; float radius2 = 0.5 * 1.0000;float pass1 = voronoi_additive(mouse1 * aspectRatio, radius1, mouseGrid1 * aspectRatio, 38.0 * 0.5000); float pass2 = voronoi_additive(mouse2 * aspectRatio + vec2(10), radius2, mouseGrid2 * aspectRatio + vec2(10.0), 48.0 * 0.5000);pass1 *= 0.02; pass2 *= 0.04;color.rgb = (pass1 + pass2) * vec3(1, 1, 1) * mix(1.0, bg.r, 0.9000); color.rgb = clamp(color.rgb, 0.0, 1.0);color.rgb = blend(1, bg.rgb, color.rgb);color = vec4(color.rgb, max(bg.a, luma(color.rgb))); return color; }void main() { vec4 color;color = randomStyle(); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect4"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "glyphDither",
      "usesPingPong": false,
      "texture": {
        "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbgAAAAoCAYAAACM2+9EAAAQAElEQVR4AeydB7DVRBeAz2Lvitgb2AYLYi9YEbuoqCjqiAV7HxwLtlERO+Ngb4O+sfeuIxZ07DoWrNgdUewVwYKF/335yX0ne5PcJDe5L/eyzFuy5ezZzclNzu5p20VEprnkaOB+A+434H4D7jfQar8BGFz7Pbk/RwFHAUcBR4FWpsDyyy8vp556qlx88cWy5557tvKtVu7NMbgKKVwmNQVcB0cBR4GmoMASSywhH374oZx11lly9NFHyy233CLPPfdcU8y9nkm2FIMbPny4XHrppXWlwYMH10PPVH1nm202Oe644+Stt96Sb7/9Vv744w8vkaeONmBSIS0AeIcddqii6a677lrASPEom+35xt9N57dusMEGcuONN8qLL74oEyZMkClTpsiff/4pP/74o3z66acyduxY2WuvvaRLl5b6THQ+4TthBieffLIYYwIj9+nTR2aZZZZAXasVWuqXO2zYMDnyyCPrSqNHj27IM2aekydPlgsvvFB69eolCy+8sMw+++xeIk8dbcAA25BJRQxy1VVXVdGUugjwwqqb6fkWRoQcEG+44Yby3nvvyQsvvCB77723rL/++rLUUkvJnHPOKSyounbtKj169JC+ffvKzTffLH/99ZfwvHNmdDnciUORlAJ8U2xYY4xjcDZRXLl+Ctx6663ejmjmmWeuiQwYdqX0qQlcAMCCCy4oiy++eBXmbt26yZJLLllV7yrKTYFTTjnFE02ttNJKiSfKb/CQQw7xpAzocRJ3dIClocANN9xQNRd26r///ntVfStVdGmlm/niiy/kp59+Ck32fUbBgcOGzbPMB2aPPfaoQvnff//JxIkTvUTeBqAPfe36osuHHXZY5BDI8iMbC2jg2UQ9N3u4KDhw2LAzSnnQoEEyYsSIqtv9559/BLq88sor3q7uo48+8nZtNiCLmjfeeEO42m2uXG4KPPjgg94uHKb23XffeSJodu/lnnXM7BI2tRSDW2655YQdR1jSTIN8GAx14EhIu9Rg4EePpDsyF5jXTDPN5O2I2BWRp442DUtfcOi6ovNx1lYDBw4sevgAfp4N9x+WNK3Ih8FQB44A0hmocMkllwTudtq0aXLllVfKfPPNJ0svvbSst956gvhyxRVX9ETl6KN/++030f/mnntu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",
        "sampler": "uCustomTexture"
      },
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform sampler2D uSprite; uniform sampler2D uCustomTexture;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src; }out vec4 fragColor;const float GLYPH_HEIGHT = 40.0;void main() { vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); float aspectRatio = uResolution.x / uResolution.y; float aspectCorrection = mix(aspectRatio, 1./aspectRatio, 0.5);float gridSize = mix(0.05, 0.005, 0.9600);float baseGrid = 1.0 / gridSize; vec2 cellSize = vec2(1.0/(baseGrid * aspectRatio), 1.0/baseGrid) * aspectCorrection; vec2 offsetUv = uv - pos; vec2 cell = floor(offsetUv / cellSize); vec2 cellCenter = (cell + 0.5) * cellSize; vec2 pixelatedCoord = cellCenter + pos; vec4 bg = texture(uTexture, vTextureCoord); vec4 color = texture(uTexture, pixelatedCoord);float luminance = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722)); luminance = mix(luminance, 1.0 - luminance, float(0)); float gamma = pow(mix(0.2, 2.2, 0.3800), 2.2);float scaleFactor = gridSize / GLYPH_HEIGHT;ivec2 customTextureSize = textureSize(uCustomTexture, 0); ivec2 spriteTextureSize = textureSize(uSprite, 0); float selectedWidth = mix(float(spriteTextureSize.x), float(customTextureSize.x), float(6 == 6)); float numSprites = max(1.0, selectedWidth / GLYPH_HEIGHT); float numGlyphRows = 1.0;float spriteIndex = clamp(floor(luminance * numSprites), 0.0, numSprites - 1.0); float spriteIndexWithGamma = clamp(floor(luminance * numSprites * gamma), 0.0, numSprites - 1.0); float glyphIndex = 0.0;float normalizedSpriteSizeX = 1.0 / numSprites; float normalizedSpriteSizeY = 1.0 / numGlyphRows;float spriteX = (spriteIndexWithGamma * normalizedSpriteSizeX);vec2 spriteSheetUV = vec2( spriteX, glyphIndex / numGlyphRows );vec2 spriteSize = vec2(GLYPH_HEIGHT / aspectRatio, GLYPH_HEIGHT) * scaleFactor * aspectCorrection; vec2 localOffset = mod(uv - pos, spriteSize) / spriteSize;spriteSheetUV += vec2( localOffset.x * normalizedSpriteSizeX, localOffset.y * normalizedSpriteSizeY );vec4 spriteColor = vec4(0.0);spriteColor = texture(uCustomTexture, spriteSheetUV); float alpha = smoothstep(0.0, 1.0, spriteColor.r);vec3 cc = (color.rgb - spriteIndex * 0.04) * 1.4; vec3 col = mix(cc, vec3(0, 1, 1), float(0)); vec3 dithered = mix( mix(vec3(0.0), vec3(1.0), float(0)), col, alpha ); vec3 blended = blend(0, dithered, bg.rgb); color.rgb = mix(bg.rgb, blended, 1.0000); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": {
        "depth": false,
        "uniforms": {},
        "isBackground": false,
        "texture": { "src": "", "sampler": "uSprite" }
      },
      "id": "effect5"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "duotone",
      "usesPingPong": false,
      "texture": false,
      "animating": false,
      "mouseMomentum": 0,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture;out vec4 fragColor; void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114)); vec3 duotoneColor = mix(vec3(0.9607843137254902, 0.9568627450980393, 0.9607843137254902), vec3(0.4392156862745098, 0.6627450980392157, 0.9372549019607843), gray); color = vec4(mix(color.rgb, duotoneColor, 1.0000), color.a); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect6"
    }
  ],
  "options": {
    "name": "IOAI Hero (Remix)",
    "fps": 60,
    "dpi": 1.5,
    "scale": 1,
    "includeLogo": false,
    "isProduction": false
  },
  "version": "1.4.33",
  "id": "9K6OQfZ4qTiG5S6vPF26"
}
