{
  "history": [
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "gradient",
      "usesPingPong": false,
      "speed": 0.25,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) { switch(index) { case 0: return vec3(0, 0, 0); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"
      ],
      "data": {
        "downSample": 0.5,
        "depth": false,
        "uniforms": {},
        "isBackground": true
      },
      "id": "effect"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "pattern",
      "usesPingPong": false,
      "speed": 0.19,
      "texture": false,
      "animating": true,
      "mouseMomentum": 0,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uTime; uniform vec2 uResolution;mat2 rotate2d(float _angle){ return mat2(cos(_angle),-sin(_angle), sin(_angle),cos(_angle)); } float gridSDF(vec2 st, float tile) { vec2 grid = fract(st); vec2 distToEdge = min(grid, 1.0 - grid); float minDist = min(distToEdge.x, distToEdge.y); return minDist - tile * 0.5; }float stripeSDF(vec2 st, float tile) { float x = fract(st.x - uTime * 0.05); return abs(x - 0.5) - tile * 0.5; }float arrowsSDF(vec2 st, float tile) { vec2 grid = floor(st); vec2 cell = fract(st); float checker = mod(grid.x + grid.y, 2.0); float arrow = checker > 0.5 ? cell.x : cell.y; return abs(arrow - 0.5) - tile * 0.5; }float concentricCircleSDF(vec2 st, float tile) { float r = length(st); return abs(fract(r) - 0.5) - tile * 0.5; }float circleSDF(vec2 st, float tile) { vec2 cell = fract(st) - 0.5; float dist = length(cell); return dist - tile * 0.5; }float checkerboardSDF(vec2 st, float tile) { vec2 grid = floor(st); vec2 cell = fract(st) - 0.5; float checker = mod(grid.x + grid.y, 2.0); return checker > 0.5 ? -1.0 : 1.0; }float wavyLinesSDF(vec2 st, float tile) { float wave = sin(st.x * 6.28318 + st.y * 10.0) * 0.5 + 0.5; return abs(wave - 0.5) - tile * 0.5; }float hexagonalSDF(vec2 st, float tile) { const float sqrt3 = 1.732050808; st = abs(st); float d = dot(st, normalize(vec2(1.0, sqrt3))); return max(d, st.x) - tile; }float diamondSDF(vec2 st, float tile) { vec2 cell = fract(st) - 0.5; float d = abs(cell.x) + abs(cell.y); return d - tile * 0.5; }float spiralSDF(vec2 st, float tile) { float r = length(st); float theta = atan(st.y, st.x); float spiral = fract((theta + r * 5.0) / 6.28318); return abs(spiral - 0.5) - tile * 0.5; }float getPatternSDF(vec2 st, float tile) { st.y -= uTime * 0.05; switch(5) { case 0: return gridSDF(st, tile); case 1: return stripeSDF(st, tile); case 2: return circleSDF(st, tile); case 3: return concentricCircleSDF(st, tile); case 4: return arrowsSDF(st, tile); case 5: return checkerboardSDF(st, tile); case 6: return wavyLinesSDF(st, tile); case 7: return hexagonalSDF(st, tile); case 8: return diamondSDF(st, tile); case 9: return spiralSDF(st, tile); default: return gridSDF(st, tile); } }out vec4 fragColor; void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);if(bg.a == 0.) { fragColor = vec4(0); return; } vec4 color = vec4(vec3(0, 0.4, 0.8),1.); float aspectRatio = uResolution.x/uResolution.y; float res = max(uResolution.x, uResolution.y); float px = (1./res); float py = px / aspectRatio; float scl = (40. * 0.2010); float minpx = min(px, py); float tile = (minpx + 0.1000/scl)*scl; tile = round(tile / minpx) * minpx;vec2 st = (uv - vec2(0.5, 0.5)) * scl * vec2(aspectRatio, 1); st = st * rotate2d(0.0000 * 360. * 3.1415926 / 180.); float sdf = getPatternSDF(st, tile); float smoothRadius = minpx * scl; float pattern = 1.0 - smoothstep(-smoothRadius, smoothRadius, sdf);color *= pattern; fragColor = mix(bg, color, color.a * 1.0000); }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect1"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "sine",
      "usesPingPong": false,
      "speed": 0,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": true,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float;in vec2 vTextureCoord; in vec3 vVertexPosition; uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } out vec4 fragColor;const float PI = 3.141592;void main() { vec2 uv = vTextureCoord; vec2 waveCoord = vTextureCoord.xy * 2.0 - 1.0; float thirdPI = PI * 0.3333; float time = uTime * 0.25; float frequency = 20.0 * 0.5000; float amp = 0.3000 * 0.2;float waveX = sin((waveCoord.y + vec2(0.5, 0.5).y) * frequency + (time * thirdPI)) * amp; float waveY = sin((waveCoord.x - vec2(0.5, 0.5).x) * frequency + (time * thirdPI)) * amp; waveCoord.xy += vec2(mix(waveX, 0., 0.0000), mix(0., waveY, 0.0000));vec2 finalUV = waveCoord * 0.5 + 0.5; float aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); float dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000)));if (0 == 1) { dist = max(0., (0.5 - dist)); } uv = mix(uv, finalUV, dist);vec4 color = texture(uTexture, uv); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect2"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "pixelate",
      "usesPingPong": false,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor; void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); float gridSize = (1.0000 + 0.01) * 0.083; float baseGrid = 1.0 / gridSize; vec2 cellSize = vec2(1.0/(baseGrid * aspectRatio), 1.0/baseGrid) * mix(aspectRatio, 1./aspectRatio, 0.5); vec2 offsetUv = uv - pos; vec2 cell = floor(offsetUv / cellSize); vec2 cellCenter = (cell + 0.5) * cellSize; vec2 pixelatedCoord = cellCenter + pos; vec2 relativePos = mod(offsetUv, cellSize) / cellSize - 0.5; float dist = length(relativePos); float x = mix(uv.x, pixelatedCoord.x, vec2(1, 1).x); float y = mix(uv.y, pixelatedCoord.y, vec2(1, 1).y); vec4 color = texture(uTexture, vec2(x, y)); float edgeSmoothing = 0.02; float alpha = 1.0 - smoothstep(1.0000 - edgeSmoothing, 1.0000, dist); if(1 == 1) { color.rgb = mix(vec3(0, 0, 0), color.rgb, alpha); } else { color.a *= alpha; }color *= color.a; fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect3"
    }
  ],
  "options": {
    "name": "Untitled project",
    "fps": 60,
    "dpi": 1.5,
    "scale": 1,
    "includeLogo": false,
    "isProduction": false
  },
  "version": "1.4.33",
  "id": "IFtgdniy8Ky3ht5gacVW"
}
